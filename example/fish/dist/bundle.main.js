/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./EngineCore/Core.js":
/*!****************************!*\
  !*** ./EngineCore/Core.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _Lib_CollisionInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lib/CollisionInfo */ \"./Lib/CollisionInfo.js\");\n\r\n\r\n\r\nclass Engine {\r\n    constructor() {\r\n        this.mWidth = 800;\r\n        this.mHeight = 450;\r\n        this.gravity = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 10);\r\n        this.collisionResolve=true;\r\n\r\n        this.mPositionalCorrectionFlag = true;\r\n        this.mRelaxationCount = 15;                  // number of relaxation iteration\r\n        this.mPosCorrectionRate = 0.8;               // percentage of separation to project objects\r\n\r\n        this.mCanvas = document.getElementById('canvas');\r\n        this.mContext = this.mCanvas.getContext('2d');\r\n        this.mCanvas.height = this.mHeight;\r\n        this.mCanvas.width = this.mWidth;\r\n\r\n        this.mCurrentTime=0;\r\n        this.mElapsedTime=0;\r\n        this.mPreviousTime = Date.now();\r\n        this.mLagTime = 0;\r\n        this.kFPS = 60;          // Frames per second\r\n        this.kFrameTime = 1 / this.kFPS;\r\n        this.mUpdateIntervalInSeconds = this.kFrameTime;\r\n        this.kMPF = 1000 * this.kFrameTime; // Milliseconds per frame.\r\n\r\n        this.mAllObjects = [];\r\n        this.mMovement = true;\r\n    }\r\n\r\n    addObject(obj) {\r\n        this.mAllObjects.push(obj);\r\n    }\r\n\r\n    getAllObject(){\r\n        return this.mAllObjects;\r\n    }\r\n\r\n    draw(){\r\n        this.mContext.clearRect(0, 0, this.mWidth, this.mHeight);\r\n        let i;\r\n        for (i = 0; i < this.mAllObjects.length; i++) {\r\n\r\n            if(this.mAllObjects[i].collided){\r\n                this.mContext.strokeStyle = 'red';\r\n            }else{\r\n                this.mContext.strokeStyle = 'blue';\r\n            }\r\n            this.mAllObjects[i].draw(this.mContext);\r\n        }\r\n    };\r\n\r\n    init(opts){\r\n        Object.assign(this,opts);\r\n        this.runGameLoop();\r\n    }\r\n\r\n    update(){\r\n        let i;\r\n        let mAllObjects = this.getAllObject();\r\n        for (i = 0; i < mAllObjects.length; i++) {\r\n            mAllObjects[i].update(this.mContext);\r\n        }\r\n    }\r\n\r\n    remove(obj){\r\n        const index = this.mAllObjects.indexOf(obj);\r\n\r\n        if (index > -1) {\r\n            this.mAllObjects.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    runGameLoop(){\r\n        requestAnimationFrame(() => {\r\n            this.runGameLoop();\r\n        });\r\n\r\n        this.mCurrentTime = Date.now();\r\n        this.mElapsedTime = this.mCurrentTime - this.mPreviousTime;\r\n        this.mPreviousTime = this.mCurrentTime;\r\n        this.mLagTime += this.mElapsedTime;\r\n\r\n        while (this.mLagTime >= this.kMPF) {\r\n            this.mLagTime -= this.kMPF;\r\n            this.collision();\r\n            this.update();\r\n        }\r\n        this.draw();\r\n    }\r\n\r\n\r\n    collision(){\r\n        let i;\r\n        let j;\r\n        let k;\r\n        const collisionInfo = new _Lib_CollisionInfo__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\r\n        var mAllObjects=this.getAllObject();\r\n        // for (k = 0; k < this.mRelaxationCount; k++) {\r\n        for (var l = 0; l < mAllObjects.length; l++) {\r\n            mAllObjects[l].collided=false;\r\n        }\r\n        for (i = 0; i < mAllObjects.length; i++) {\r\n            for (j = i + 1; j < mAllObjects.length; j++) {\r\n                if (mAllObjects[i].boundTest(mAllObjects[j])) {\r\n                    if (mAllObjects[i].collisionTest(mAllObjects[j], collisionInfo)) {\r\n                        mAllObjects[i].collided=true;\r\n                        mAllObjects[j].collided=true;\r\n                        if(this.collisionResolve) {\r\n                            if (collisionInfo.getNormal().dot(mAllObjects[j].mCenter.subtract(mAllObjects[i].mCenter)) < 0) {\r\n                                collisionInfo.changeDir();\r\n                            }\r\n                            this.resolveCollision(mAllObjects[i], mAllObjects[j], collisionInfo);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // }\r\n    };\r\n\r\n\r\n    positionalCorrection(s1, s2, collisionInfo){\r\n        const s1InvMass = s1.mInvMass;\r\n        const s2InvMass = s2.mInvMass;\r\n\r\n        const num = collisionInfo.getDepth() / (s1InvMass + s2InvMass) * this.mPosCorrectionRate;\r\n        const correctionAmount = collisionInfo.getNormal().scale(num);\r\n\r\n        s1.move(correctionAmount.scale(-s1InvMass));\r\n        s2.move(correctionAmount.scale(s2InvMass));\r\n    }\r\n\r\n    resolveCollision (s1, s2, collisionInfo) {\r\n\r\n        if ((s1.mInvMass === 0) && (s2.mInvMass === 0)) {\r\n            return;\r\n        }\r\n\r\n        //  correct positions\r\n        if (this.mPositionalCorrectionFlag) {\r\n            this.positionalCorrection(s1, s2, collisionInfo);\r\n        }\r\n\r\n        const n = collisionInfo.getNormal();\r\n\r\n        //the direction of collisionInfo is always from s1 to s2\r\n        //but the Mass is inversed, so start scale with s2 and end scale with s1\r\n        const start = collisionInfo.mStart.scale(s2.mInvMass / (s1.mInvMass + s2.mInvMass));\r\n        const end = collisionInfo.mEnd.scale(s1.mInvMass / (s1.mInvMass + s2.mInvMass));\r\n        const p = start.add(end);\r\n        //r is vector from center of object to collision point\r\n        const r1 = p.subtract(s1.mCenter);\r\n        const r2 = p.subtract(s2.mCenter);\r\n\r\n        //newV = V + mAngularVelocity cross R\r\n        const v1 = s1.mVelocity.add(new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](-1 * s1.mAngularVelocity * r1.y, s1.mAngularVelocity * r1.x));\r\n        const v2 = s2.mVelocity.add(new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](-1 * s2.mAngularVelocity * r2.y, s2.mAngularVelocity * r2.x));\r\n        const relativeVelocity = v2.subtract(v1);\r\n\r\n        // Relative velocity in normal direction\r\n        const rVelocityInNormal = relativeVelocity.dot(n);\r\n\r\n        //if objects moving apart ignore\r\n        if (rVelocityInNormal > 0) {\r\n            return;\r\n        }\r\n\r\n        // compute and apply response impulses for each object\r\n        const newRestituion = Math.min(s1.mRestitution, s2.mRestitution);\r\n        const newFriction = Math.min(s1.mFriction, s2.mFriction);\r\n\r\n        //R cross N\r\n        const R1crossN = r1.cross(n);\r\n        const R2crossN = r2.cross(n);\r\n\r\n        // Calc impulse scalar\r\n        // the formula of jN can be found in http://www.myphysicslab.com/collision.html\r\n        let jN = -(1 + newRestituion) * rVelocityInNormal;\r\n        jN = jN / (s1.mInvMass + s2.mInvMass +\r\n            R1crossN * R1crossN * s1.mInertia +\r\n            R2crossN * R2crossN * s2.mInertia);\r\n\r\n        //impulse is in direction of normal ( from s1 to s2)\r\n        let impulse = n.scale(jN);\r\n        // impulse = F dt = m * ?v\r\n        // ?v = impulse / m\r\n        s1.mVelocity = s1.mVelocity.subtract(impulse.scale(s1.mInvMass));\r\n        s2.mVelocity = s2.mVelocity.add(impulse.scale(s2.mInvMass));\r\n\r\n        s1.mAngularVelocity -= R1crossN * jN * s1.mInertia;\r\n        s2.mAngularVelocity += R2crossN * jN * s2.mInertia;\r\n\r\n        let tangent = relativeVelocity.subtract(n.scale(relativeVelocity.dot(n)));\r\n\r\n        //relativeVelocity.dot(tangent) should less than 0\r\n        tangent = tangent.normalize().scale(-1);\r\n\r\n        const R1crossT = r1.cross(tangent);\r\n        const R2crossT = r2.cross(tangent);\r\n\r\n        let jT = -(1 + newRestituion) * relativeVelocity.dot(tangent) * newFriction;\r\n        jT = jT / (s1.mInvMass + s2.mInvMass + R1crossT * R1crossT * s1.mInertia + R2crossT * R2crossT * s2.mInertia);\r\n\r\n        //friction should less than force in normal direction\r\n        if (jT > jN) {\r\n            jT = jN;\r\n        }\r\n\r\n        //impulse is from s1 to s2 (in opposite direction of velocity)\r\n        impulse = tangent.scale(jT);\r\n\r\n        s1.mVelocity = s1.mVelocity.subtract(impulse.scale(s1.mInvMass));\r\n        s2.mVelocity = s2.mVelocity.add(impulse.scale(s2.mInvMass));\r\n        s1.mAngularVelocity -= R1crossT * jT * s1.mInertia;\r\n        s2.mAngularVelocity += R2crossT * jT * s2.mInertia;\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (new Engine());\n\n//# sourceURL=webpack:///./EngineCore/Core.js?");

/***/ }),

/***/ "./Lib/CollisionInfo.js":
/*!******************************!*\
  !*** ./Lib/CollisionInfo.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec2 */ \"./Lib/Vec2.js\");\n\r\n\r\nclass CollisionInfo {\r\n    constructor() {\r\n        this.mDepth = 0;\r\n        this.mNormal = new _Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\r\n        this.mStart = new _Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\r\n        this.mEnd = new _Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\r\n    }\r\n\r\n    /**\r\n     * Set the depth of the CollisionInfo\r\n     * @memberOf CollisionInfo\r\n     * @param {Number} s how much penetration\r\n     * @returns {void}\r\n     */\r\n    setDepth(s) {\r\n        this.mDepth = s;\r\n    }\r\n\r\n    /**\r\n     * Set the normal of the CollisionInfo\r\n     * @memberOf CollisionInfo\r\n     * @param {vec2} s vector upon which collision interpenetrates\r\n     * @returns {void}\r\n     */\r\n    setNormal(s) {\r\n        this.mNormal = s;\r\n    }\r\n\r\n    /**\r\n     * Return the depth of the CollisionInfo\r\n     * @memberOf CollisionInfo\r\n     * @returns {Number} how much penetration\r\n     */\r\n    getDepth() {\r\n        return this.mDepth;\r\n    }\r\n\r\n    /**\r\n     * Return the depth of the CollisionInfo\r\n     * @memberOf CollisionInfo\r\n     * @returns {vec2} vector upon which collision interpenetrates\r\n     */\r\n    getNormal() {\r\n        return this.mNormal;\r\n    }\r\n\r\n    /**\r\n     * Set the all value of the CollisionInfo\r\n     * @memberOf CollisionInfo\r\n     * @param {Number} d the depth of the CollisionInfo\r\n     * @param {Vec2} n the normal of the CollisionInfo\r\n     * @param {Vec2} s the startpoint of the CollisionInfo\r\n     * @returns {void}\r\n     */\r\n    setInfo(d, n, s) {\r\n        this.mDepth = d;\r\n        this.mNormal = n;\r\n        this.mStart = s;\r\n        this.mEnd = s.add(n.scale(d));\r\n    }\r\n\r\n    /**\r\n     * change the direction of normal\r\n     * @memberOf CollisionInfo\r\n     * @returns {void}\r\n     */\r\n    changeDir() {\r\n        this.mNormal = this.mNormal.scale(-1);\r\n        const n = this.mStart;\r\n        this.mStart = this.mEnd;\r\n        this.mEnd = n;\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (CollisionInfo);\n\n//# sourceURL=webpack:///./Lib/CollisionInfo.js?");

/***/ }),

/***/ "./Lib/Vec2.js":
/*!*********************!*\
  !*** ./Lib/Vec2.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Vec2 {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    add(vec) {\r\n        return new Vec2(vec.x + this.x, vec.y + this.y);\r\n    }\r\n\r\n    subtract(vec) {\r\n        return new Vec2(this.x - vec.x, this.y - vec.y);\r\n    }\r\n\r\n    scale(n) {\r\n        return new Vec2(this.x * n, this.y * n);\r\n    }\r\n\r\n    length() {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    dot(vec) {\r\n        return (this.x * vec.x + this.y * vec.y);\r\n    }\r\n\r\n    cross(vec) {\r\n        return (this.x * vec.y - this.y * vec.x);\r\n    }\r\n\r\n    rotate(center, angle) {\r\n        let x1;\r\n        let y1;\r\n\r\n        const x = this.x - center.x;\r\n        const y = this.y - center.y;\r\n\r\n        x1 = x * Math.cos(angle) - y * Math.sin(angle);\r\n        y1 = x * Math.sin(angle) + y * Math.cos(angle);\r\n\r\n        x1 += center.x;\r\n        y1 += center.y;\r\n\r\n        return new Vec2(x1, y1);\r\n    }\r\n\r\n    normalize() {\r\n\r\n        let len = this.length();\r\n        if (len > 0) {\r\n            len = 1 / len;\r\n        }\r\n        return new Vec2(this.x * len, this.y * len);\r\n    }\r\n\r\n    distance(vec) {\r\n        const x = this.x - vec.x;\r\n        const y = this.y - vec.y;\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vec2);\n\n//# sourceURL=webpack:///./Lib/Vec2.js?");

/***/ }),

/***/ "./Lib/utils.js":
/*!**********************!*\
  !*** ./Lib/utils.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EngineCore/Core */ \"./EngineCore/Core.js\");\n\r\nfunction drawLine(start,end){\r\n    var context=_EngineCore_Core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mContext;\r\n    context.strokeStyle = 'purple';\r\n    context.beginPath();\r\n    context.moveTo(start.x,start.y);\r\n    context.lineTo(end.x, end.y);\r\n\r\n    context.closePath();\r\n    context.stroke();\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    drawLine:drawLine\r\n});\n\n//# sourceURL=webpack:///./Lib/utils.js?");

/***/ }),

/***/ "./MyGame.js":
/*!*******************!*\
  !*** ./MyGame.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RigidBody_Rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RigidBody/Rectangle */ \"./RigidBody/Rectangle.js\");\n/* harmony import */ var _RigidBody_Polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RigidBody/Polygon */ \"./RigidBody/Polygon.js\");\n/* harmony import */ var _RigidBody_Circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RigidBody/Circle */ \"./RigidBody/Circle.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EngineCore/Core */ \"./EngineCore/Core.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction MyGame() {\r\n    var r1 = new _RigidBody_Rectangle__WEBPACK_IMPORTED_MODULE_0__[\"default\"](new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](500, 200), 400, 20, 0, 0.3, 0.1);\r\n    r1.rotate(2.8);\r\n    var r2 = new _RigidBody_Rectangle__WEBPACK_IMPORTED_MODULE_0__[\"default\"](new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](200, 400), 400, 20, 0, 1, 0.1);\r\n    var r3 = new _RigidBody_Rectangle__WEBPACK_IMPORTED_MODULE_0__[\"default\"](new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](100, 200), 200, 20, 0);\r\n\r\n    var p1 = new _RigidBody_Polygon__WEBPACK_IMPORTED_MODULE_1__[\"default\"]([new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](100, 200),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](200, 200),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](250, 250),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](50, 250)], 30, 300, 1);\r\n    var p2 = new _RigidBody_Polygon__WEBPACK_IMPORTED_MODULE_1__[\"default\"]([new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](350, 0),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](400, -50),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](450, 0),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](425, 100),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](375, 100)], 20,0.2, 0.3);\r\n\r\n    var r4 = new _RigidBody_Rectangle__WEBPACK_IMPORTED_MODULE_0__[\"default\"](new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](200, 100), 40, 20, 0, 1, 0.1);\r\n\r\n\r\n    r4.rotate(Math.atan2(400-r4.mCenter.y,500-r4.mCenter.x))\r\n    // r4.mVelocity=new Vec2(21.136934101395795, -2.480280727694577 );\r\n\r\n    var p=1;\r\n    setInterval(function(){\r\n        if(r4.mCenter.x<500&&p==1) {\r\n            var dist=new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](500,400);\r\n            var desire = dist.subtract(r4.mCenter);\r\n            r4.mAcceleration = desire.subtract(r4.mVelocity);\r\n            var steer=r4.mAcceleration.normalize().scale(30);\r\n            r4.mAngularAcceleration=((r4.mVertex[1].add(r4.mVertex[2]).scale(0.5).subtract(r4.mCenter)).cross(steer)/1000);\r\n        }else{\r\n            p=2;\r\n            var dist=new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_3__[\"default\"](200,300);\r\n            var desire = dist.subtract(r4.mCenter);\r\n            r4.mAcceleration = desire.subtract(r4.mVelocity);\r\n            var steer=r4.mAcceleration.normalize().scale(30);\r\n            r4.mAngularAcceleration=((r4.mVertex[1].add(r4.mVertex[2]).scale(0.5).subtract(r4.mCenter)).cross(steer)/1000);\r\n        }\r\n    },50);\r\n\r\n\r\n   /* for (var i = 0; i < 2; i++) {\r\n        var centerX=Math.random() * Engine.mWidth,\r\n            centerY=Math.random() * Engine.mHeight / 2,\r\n            radius=Math.random() * 20 + 10,\r\n            mass=Math.random() * 30,\r\n            friction= Math.random(),\r\n            restitution=Math.random();\r\n\r\n\r\n       /!* var r1 = new Circle(new Vec2(260.7774466923317, 53.158349874831984), 13.690461478357165 ,8.68975181178399 ,0.7357455942757951 ,0.024662666834935676);\r\n\r\n         var vx=Math.random() * 60 - 30,vy=Math.random() * 60 - 30;\r\n         r1.mVelocity = new Vec2(21.136934101395795, -2.480280727694577 );*!/\r\n\r\n        //圆形正常代码\r\n        var r2 = new Circle(new Vec2(Math.random() * Engine.mWidth, Math.random() * Engine.mHeight / 2), Math.random() * 20 + 10, Math.random() * 30, Math.random(), Math.random());\r\n        r2.mVelocity = new Vec2(Math.random() * 60 - 30, Math.random() * 60 - 30);\r\n\r\n        //矩形调试代码\r\n        var centerX=Math.random() * Engine.mWidth,\r\n            centerY=Math.random() * Engine.mHeight / 2,\r\n            width=Math.random() * 50 + 10,\r\n            height=Math.random() * 50 + 10,\r\n            mass=Math.random() * 30,\r\n            friction= Math.random(),\r\n            restitution=Math.random();\r\n\r\n\r\n        var r3 = new Rectangle(new Vec2(centerX, centerY),  width,height, mass, friction, restitution);\r\n\r\n        var vx=Math.random() * 60 - 30,vy=Math.random() * 60 - 30;\r\n        r3.mVelocity = new Vec2(vx,vy);\r\n\r\n        //矩形正常代码\r\n        /!*       var r1 = new Rectangle(new Vec2(559.6844169945291, 31.316602433838884), 26.4886973392982 ,47.13979461975169 ,16.210394630327222 ,0.5568285280768372 ,0.5611291606843027 );\r\n         r1.mVelocity = new Vec2(-27.64823839880822, 28.770085623239808);\r\n\r\n         var r1 = new Rectangle(new Vec2(559.6844169945291, 31.316602433838884), 60.4886973392982 ,47.13979461975169 ,16.210394630327222 ,0.5568285280768372 ,0.5611291606843027 );\r\n         r1.mVelocity = new Vec2(-27.64823839880822, 28.770085623239808);*!/\r\n    }*/\r\n}\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyGame);\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./MyGame.js?");

/***/ }),

/***/ "./RigidBody/Circle.js":
/*!*****************************!*\
  !*** ./RigidBody/Circle.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RigidShape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RigidShape */ \"./RigidBody/RigidShape.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n\r\n\r\n\r\nclass Circle extends _RigidShape__WEBPACK_IMPORTED_MODULE_0__[\"default\"]{\r\n    constructor(center, radius, mass, friction, restitution) {\r\n        super(center, mass, friction, restitution);\r\n        this.mType = \"Circle\";\r\n        this.mRadius = radius;\r\n        this.mBoundRadius = radius;\r\n        this.mStartpoint = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](center.x, center.y - radius);\r\n        this.updateInertia();\r\n    }\r\n\r\n    move(s) {\r\n        this.mStartpoint = this.mStartpoint.add(s);\r\n        this.mCenter = this.mCenter.add(s);\r\n        return this;\r\n    }\r\n\r\n    draw(context) {\r\n        context.beginPath();\r\n\r\n        context.arc(this.mCenter.x, this.mCenter.y, this.mRadius, 0, Math.PI * 2, true);\r\n\r\n        context.moveTo(this.mStartpoint.x, this.mStartpoint.y);\r\n        context.lineTo(this.mCenter.x, this.mCenter.y);\r\n\r\n        context.closePath();\r\n        context.stroke();\r\n    }\r\n\r\n    rotate(angle) {\r\n        this.mAngle += angle;\r\n        this.mStartpoint = this.mStartpoint.rotate(this.mCenter, angle);\r\n        return this;\r\n    }\r\n\r\n    updateInertia() {\r\n        if (this.mInvMass === 0) {\r\n            this.mInertia = 0;\r\n        } else {\r\n            // this.mInvMass is inverted!!\r\n            // Inertia=mass * radius^2\r\n            // 12 is a constant value that can be changed\r\n            this.mInertia = (1 / this.mInvMass) * (this.mRadius * this.mRadius) / 12;\r\n        }\r\n    }\r\n\r\n    collisionTest(otherShape, collisionInfo) {\r\n        let status = false;\r\n        if (otherShape.mType === \"Circle\") {\r\n            status = this.collidedCircCirc(this, otherShape, collisionInfo);\r\n        } else {\r\n            status = otherShape.collidedRectCirc(this, collisionInfo);\r\n        }\r\n        return status;\r\n    }\r\n\r\n    collidedCircCirc(c1, c2, collisionInfo) {\r\n        const vFrom1to2 = c2.mCenter.subtract(c1.mCenter);\r\n        const rSum = c1.mRadius + c2.mRadius;\r\n        const dist = vFrom1to2.length();\r\n        //圆心距离大于半径之和\r\n        if (dist > Math.sqrt(rSum * rSum)) {\r\n            return false;\r\n        }\r\n        if (dist !== 0) {\r\n            //有重叠但位置不同\r\n            const normalFrom2to1 = vFrom1to2.scale(-1).normalize();\r\n            const radiusC2 = normalFrom2to1.scale(c2.mRadius);\r\n            collisionInfo.setInfo(rSum - dist, vFrom1to2.normalize(), c2.mCenter.add(radiusC2));\r\n        } else {\r\n            //位置相同\r\n            if (c1.mRadius > c2.mRadius) {\r\n                collisionInfo.setInfo(rSum, new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, -1), c1.mCenter.add(new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, c1.mRadius)));\r\n            } else {\r\n                collisionInfo.setInfo(rSum, new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, -1), c2.mCenter.add(new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, c2.mRadius)));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Circle);\n\n//# sourceURL=webpack:///./RigidBody/Circle.js?");

/***/ }),

/***/ "./RigidBody/Polygon.js":
/*!******************************!*\
  !*** ./RigidBody/Polygon.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RigidShape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RigidShape */ \"./RigidBody/RigidShape.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EngineCore/Core */ \"./EngineCore/Core.js\");\n\r\n\r\n\r\n\r\nconst Vertices={};\r\n\r\nVertices.centre = vertices => {\r\n    const area = Vertices.area(vertices, true);\r\n    let centre = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"]( 0,  0 );\r\n    let cross;\r\n    let temp;\r\n    let j;\r\n\r\n    for (let i = 0; i < vertices.length; i++) {\r\n        j = (i + 1) % vertices.length;\r\n        cross = vertices[i].cross(vertices[j]);\r\n        temp = vertices[i].add(vertices[j]).scale(cross);\r\n        centre = centre.add(temp);\r\n    }\r\n\r\n    return centre.scale(1/(6 * area));\r\n};\r\n\r\nVertices.area = (vertices, signed) => {\r\n    let area = 0;\r\n    let j = vertices.length - 1;\r\n\r\n    for (let i = 0; i < vertices.length; i++) {\r\n        area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\r\n        j = i;\r\n    }\r\n\r\n    if (signed)\r\n        return area / 2;\r\n    return Math.abs(area) / 2;\r\n};\r\n\r\nVertices.inertia = (vertices, mass) => {\r\n    let numerator = 0;\r\n    let denominator = 0;\r\n    const v = vertices;\r\n    let cross;\r\n    let j;\r\n\r\n    for (let n = 0; n < v.length; n++) {\r\n        j = (n + 1) % v.length;\r\n        cross = Math.abs(v[j].cross(v[n]));\r\n        numerator += cross * (v[j].dot( v[j]) + v[j].dot( v[n]) + v[n].dot( v[n]));\r\n        denominator += cross;\r\n    }\r\n\r\n    return (mass / 6) * (numerator / denominator);\r\n};\r\n\r\nclass Polygon extends _RigidShape__WEBPACK_IMPORTED_MODULE_0__[\"default\"]{\r\n    constructor(vertices, mass, friction, restitution) {\r\n        const center=Vertices.centre(vertices);\r\n        super(center, mass, friction, restitution);\r\n        this.mType = \"Polygon\";\r\n\r\n        this.mVertex = vertices;\r\n        this.mBoundRadius = this.getRadius(this.mVertex);\r\n        this.mFaceNormal=this.getAxes();\r\n        this.updateInertia();\r\n    }\r\n\r\n    getRadius(vertices) {\r\n        let radius = 0;\r\n\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            if(vertices[i].distance(this.mCenter)>radius){\r\n                radius=vertices[i].distance(this.mCenter)\r\n            }\r\n        }\r\n\r\n        return radius;\r\n    }\r\n\r\n    getAxes() {\r\n        const axes = [];\r\n        const vertices=this.mVertex;\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            const j = (i + 1) % vertices.length;\r\n\r\n            const normal = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\r\n                vertices[j].y - vertices[i].y,\r\n                vertices[i].x - vertices[j].x\r\n            ).normalize();\r\n\r\n            axes[i] = normal;\r\n        }\r\n        return axes;\r\n    }\r\n\r\n    rotate(angle) {\r\n        this.mAngle += angle;\r\n        let i;\r\n        for (i = 0; i < this.mVertex.length; i++) {\r\n            this.mVertex[i] = this.mVertex[i].rotate(this.mCenter, angle);\r\n        }\r\n        this.mFaceNormal=this.getAxes();\r\n        return this;\r\n    }\r\n\r\n    move(v) {\r\n        let i;\r\n        for (i = 0; i < this.mVertex.length; i++) {\r\n            this.mVertex[i] = this.mVertex[i].add(v);\r\n        }\r\n        this.mCenter = this.mCenter.add(v);\r\n        return this;\r\n    }\r\n\r\n    draw(context) {\r\n        context.save();\r\n        context.beginPath();\r\n        const vertices=this.mVertex;\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            const j = (i + 1) % vertices.length;\r\n            context.moveTo(this.mVertex[i].x, this.mVertex[i].y);\r\n            context.lineTo(this.mVertex[j].x, this.mVertex[j].y);\r\n        }\r\n        context.closePath();\r\n        context.stroke();\r\n\r\n        context.translate(this.mVertex[0].x, this.mVertex[0].y);\r\n        context.rotate(this.mAngle);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    updateInertia() {\r\n        // Expect this.mInvMass to be already inverted!\r\n        if (this.mInvMass === 0) {\r\n            this.mInertia = 0;\r\n        } else {\r\n            this.mInertia=Vertices.inertia(this.mVertex,this.mMass);\r\n            this.mInertia = 1 / this.mInertia;\r\n        }\r\n    }\r\n\r\n    collisionTest(otherShape, collisionInfo) {\r\n        let status = false;\r\n        if (otherShape.mType === \"Circle\") {\r\n            status = this.collidedRectCirc(otherShape, collisionInfo);\r\n        } else {\r\n            status = this.collidedRectRect(this, otherShape, collisionInfo);\r\n        }\r\n        return status;\r\n    }\r\n\r\n    collidedRectRect(A, B, collisionInfo) {\r\n        //在A上寻找分离轴\r\n        const overlapAB = getOverLap(A,B,A.mFaceNormal);\r\n        if(overlapAB.overlap<=0){\r\n            return false;\r\n        }\r\n\r\n        //在B上寻找分离轴\r\n        const overlapBA = getOverLap(B,A,B.mFaceNormal);\r\n        if(overlapBA.overlap<=0){\r\n            return false;\r\n        }\r\n\r\n        let minOverlap;\r\n        if(overlapAB.overlap<overlapBA.overlap){\r\n            minOverlap=overlapAB;\r\n        }else{\r\n            minOverlap=overlapBA;\r\n        }\r\n\r\n        //纠正轴向量的方向\r\n        if (minOverlap.axis.dot( B.mCenter.subtract( A.mCenter)) < 0) {\r\n            minOverlap.axis=minOverlap.axis.scale(-1);\r\n        }\r\n\r\n        //寻找支撑点\r\n        const supportB=A.findSupportPoint(minOverlap.axis,B);   //在B上找支撑点,A是小盒子\r\n        const supportA=B.findSupportPoint(minOverlap.axis.scale(-1),A);   //在A上找支撑点\r\n        let support;\r\n        const gContext=_EngineCore_Core__WEBPACK_IMPORTED_MODULE_2__[\"default\"].mContext;\r\n\r\n        support=supportB;\r\n        if(contains(B.mVertex,supportA)){\r\n            support=supportA;\r\n        }\r\n\r\n        /* gContext.strokeStyle = 'purple';\r\n         gContext.beginPath();\r\n         gContext.moveTo(0,0);\r\n         gContext.lineTo(support.x, support.y);\r\n\r\n         gContext.closePath();\r\n         gContext.stroke();*/\r\n\r\n        collisionInfo.setInfo(minOverlap.overlap, minOverlap.axis, support);\r\n        return true;\r\n    }\r\n\r\n    findSupportPoint(axis, rect) {\r\n        let support=null;\r\n        let vertex;\r\n        let distance;\r\n        let nearestDistance=Number.MAX_VALUE;\r\n\r\n        const tempVertex= new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0,0);\r\n\r\n        const vertices=rect.mVertex;\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            vertex = vertices[i];\r\n            tempVertex.x = vertex.x - this.mCenter.x;\r\n            tempVertex.y = vertex.y - this.mCenter.y;\r\n            distance = tempVertex.dot(axis);\r\n\r\n            if (distance < nearestDistance) {\r\n                nearestDistance = distance;\r\n                support = vertices[i];\r\n            }\r\n        }\r\n        return support;\r\n    }\r\n\r\n    collidedRectCirc(circle, collisionInfo) {\r\n        const circ2Pos=circle.mCenter;\r\n        let minDistance =circ2Pos.distance(this.mVertex[0]);\r\n        let nearestEdge = 0;\r\n        let i;\r\n\r\n        for (i = 1; i < this.mVertex.length; i++) {\r\n            //连接各顶点到圆心的向量，投影在各轴向量上\r\n            const distance=circ2Pos.distance(this.mVertex[i]);\r\n            if (distance < minDistance) {           //只要有一处投影长度大于0，说明圆心在矩形外\r\n                minDistance=distance;\r\n                nearestEdge=i;\r\n            }\r\n        }\r\n        const axis=[circle.mCenter.subtract(this.mVertex[nearestEdge]).normalize()];\r\n\r\n        const overlapAB=getOverLap(circle,this,axis);         //检测圆心和最近顶点组成的轴上是否有重合\r\n        if(overlapAB.overlap<=0){\r\n            return false;\r\n        }\r\n\r\n        //在B上寻找分离轴\r\n        const overlapBA=getOverLap(circle,this,this.mFaceNormal);          //检测圆心和最近顶点组成的轴上是否有重合\r\n        if(overlapBA.overlap<=0){\r\n            return false;\r\n        }\r\n\r\n        let minOverlap;\r\n        if(overlapAB.overlap<overlapBA.overlap){\r\n            minOverlap=overlapAB;\r\n        }else{\r\n            minOverlap=overlapBA;\r\n        }\r\n\r\n        //如果碰撞轴指向了圆则反转轴的方向\r\n        if (minOverlap.axis.dot( circle.mCenter.subtract( this.mCenter)) > 0) {\r\n            minOverlap.axis=minOverlap.axis.scale(-1);\r\n        }\r\n\r\n        collisionInfo.setInfo(minOverlap.overlap, minOverlap.axis, circle.mCenter.add(minOverlap.axis.scale(circle.mRadius-minOverlap.overlap)));\r\n        return true;\r\n    }\r\n}\r\n\r\nvar contains = (vertices, point) => {\r\n    for (let i = 0; i < vertices.length; i++) {\r\n        const vertice = vertices[i];\r\n        const nextVertice = vertices[(i + 1) % vertices.length];\r\n        if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst projectToAxis = (vertices, axis) => {\r\n    const projection={};\r\n    let min = vertices[0].dot(axis);\r\n    let max = min;\r\n\r\n    for (let i = 1; i < vertices.length; i += 1) {\r\n        const dot = vertices[i].dot(axis);\r\n\r\n        if (dot > max) {\r\n            max = dot;\r\n        } else if (dot < min){\r\n            min = dot;\r\n        }\r\n    }\r\n\r\n    projection.min = min;\r\n    projection.max = max;\r\n    return projection;\r\n};\r\n\r\nvar getOverLap = (bodyA, bodyB, axes) => {\r\n    const result = { overlap: Number.MAX_VALUE };\r\n    let projectionA;\r\n    let projectionB;\r\n    let overlap;\r\n\r\n    for (const axis of axes) {\r\n        if(bodyA.mType=='Circle'){\r\n            bodyA.mVertex=[bodyA.mCenter.subtract(axis.scale(bodyA.mRadius)),bodyA.mCenter.add(axis.scale(bodyA.mRadius))]\r\n        }\r\n\r\n        projectionA=projectToAxis(bodyA.mVertex, axis);\r\n        projectionB=projectToAxis(bodyB.mVertex, axis);\r\n\r\n        overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\r\n        if (overlap <= 0) {\r\n            result.overlap = overlap;\r\n            return result;\r\n        }\r\n\r\n\r\n        if (overlap < result.overlap) {\r\n            result.overlap = overlap;\r\n            result.axis = axis;\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Polygon);\n\n//# sourceURL=webpack:///./RigidBody/Polygon.js?");

/***/ }),

/***/ "./RigidBody/Rectangle.js":
/*!********************************!*\
  !*** ./RigidBody/Rectangle.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RigidShape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RigidShape */ \"./RigidBody/RigidShape.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _Lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Lib/utils */ \"./Lib/utils.js\");\n\r\n\r\n\r\n\r\nclass Rectangle extends _RigidShape__WEBPACK_IMPORTED_MODULE_0__[\"default\"]{\r\n    constructor(center, width, height, mass, friction, restitution) {\r\n        super(center, mass, friction, restitution);\r\n        this.mType = \"Rectangle\";\r\n        this.mWidth = width;\r\n        this.mHeight = height;\r\n        this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\r\n        this.mVertex = [];\r\n        this.mFaceNormal = [];\r\n\r\n        //0--TopLeft;1--TopRight;2--BottomRight;3--BottomLeft\r\n        this.mVertex[0] = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](center.x - width / 2, center.y - height / 2);\r\n        this.mVertex[1] = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](center.x + width / 2, center.y - height / 2);\r\n        this.mVertex[2] = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](center.x + width / 2, center.y + height / 2);\r\n        this.mVertex[3] = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](center.x - width / 2, center.y + height / 2);\r\n        //0--Top;1--Right;2--Bottom;3--Left\r\n        //mFaceNormal is normal of face toward outside of matter\r\n        this.mFaceNormal=this.getAxes();\r\n        this.updateInertia();\r\n    }\r\n\r\n    getAxes() {\r\n        const axes = [];\r\n        const vertices=this.mVertex;\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            const j = (i + 1) % vertices.length;\r\n\r\n            const normal = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\r\n                vertices[j].y - vertices[i].y,\r\n                vertices[i].x - vertices[j].x\r\n            ).normalize();\r\n\r\n            axes[i] = normal;\r\n        }\r\n\r\n        return axes;\r\n    }\r\n\r\n    rotate(angle) {\r\n        this.mAngle += angle;\r\n        let i;\r\n        for (i = 0; i < this.mVertex.length; i++) {\r\n            this.mVertex[i] = this.mVertex[i].rotate(this.mCenter, angle);\r\n        }\r\n        this.mFaceNormal=this.getAxes();\r\n        return this;\r\n    }\r\n\r\n    move(v) {\r\n        let i;\r\n        for (i = 0; i < this.mVertex.length; i++) {\r\n            this.mVertex[i] = this.mVertex[i].add(v);\r\n        }\r\n        this.mCenter = this.mCenter.add(v);\r\n        return this;\r\n    }\r\n\r\n    draw(context) {\r\n        context.save();\r\n\r\n        context.translate(this.mVertex[0].x, this.mVertex[0].y);\r\n        context.rotate(this.mAngle);\r\n        context.strokeRect(0, 0, this.mWidth, this.mHeight);\r\n\r\n        context.restore();\r\n        var dist=new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](500,400);\r\n        _Lib_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0,0),dist);\r\n        _Lib_utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(this.mCenter,this.mVertex[1].add(this.mVertex[2]).scale(0.5));\r\n    }\r\n\r\n    updateInertia() {\r\n        // Expect this.mInvMass to be already inverted!\r\n        if (this.mInvMass === 0) {\r\n            this.mInertia = 0;\r\n        } else {\r\n            //inertia=mass*width^2+height^2\r\n            this.mInertia = (1 / this.mInvMass) * (this.mWidth * this.mWidth + this.mHeight * this.mHeight) / 12;\r\n            this.mInertia = 1 / this.mInertia;\r\n        }\r\n    }\r\n\r\n    collisionTest(otherShape, collisionInfo) {\r\n        let status = false;\r\n        if (otherShape.mType === \"Circle\") {\r\n            status = this.collidedRectCirc(otherShape, collisionInfo);\r\n        } else {\r\n            status = this.collidedRectRect(this, otherShape, collisionInfo);\r\n        }\r\n        return status;\r\n    }\r\n\r\n    collidedRectRect(A, B, collisionInfo) {\r\n\r\n        //在A上寻找分离轴\r\n        const overlapAB = getOverLap(A,B,A.mFaceNormal);\r\n        if(overlapAB.overlap<=0){\r\n            return false;\r\n        }\r\n\r\n        //在B上寻找分离轴\r\n        const overlapBA = getOverLap(B,A,B.mFaceNormal);\r\n        if(overlapBA.overlap<=0){\r\n            return false;\r\n        }\r\n\r\n        let minOverlap;\r\n        if(overlapAB.overlap<overlapBA.overlap){\r\n            minOverlap=overlapAB;\r\n        }else{\r\n            minOverlap=overlapBA;\r\n        }\r\n        //纠正轴向量的方向\r\n        try {\r\n            if (minOverlap.axis.dot(B.mCenter.subtract(A.mCenter)) < 0) {\r\n                minOverlap.axis = minOverlap.axis.scale(-1);\r\n            }\r\n        }catch(e){\r\n            debugger;\r\n        }\r\n        //寻找支撑点\r\n        const supportB=A.findSupportPoint(minOverlap.axis,B);   //在B上找支撑点,A是小盒子\r\n        const supportA=B.findSupportPoint(minOverlap.axis.scale(-1),A);   //在A上找支撑点\r\n        let support;\r\n\r\n        support=supportB;\r\n        if(contains(B.mVertex,supportA)){\r\n            support=supportA;\r\n\r\n        }\r\n\r\n        /*  gContext.strokeStyle = 'green';\r\n         gContext.beginPath();\r\n         gContext.moveTo(0,0);\r\n         gContext.lineTo(B.mCenter.x, B.mCenter.y);\r\n\r\n         gContext.closePath();\r\n         gContext.stroke();*/\r\n\r\n        collisionInfo.setInfo(minOverlap.overlap, minOverlap.axis, support);\r\n        return true;\r\n    }\r\n\r\n    findSupportPoint(axis, rect) {\r\n        let support=null;\r\n        let vertex;\r\n        let distance;\r\n        let nearestDistance=Number.MAX_VALUE;\r\n\r\n        const tempVertex= new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0,0);\r\n\r\n        const vertices=rect.mVertex;\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            vertex = vertices[i];\r\n            tempVertex.x = vertex.x - this.mCenter.x;\r\n            tempVertex.y = vertex.y - this.mCenter.y;\r\n            distance = tempVertex.dot(axis);\r\n\r\n            if (distance < nearestDistance) {\r\n                nearestDistance = distance;\r\n                support = vertices[i];\r\n            }\r\n        }\r\n        return support;\r\n    }\r\n\r\n    collidedRectCirc(circle, collisionInfo) {\r\n        const circ2Pos=circle.mCenter;\r\n        let minDistance =circ2Pos.distance(this.mVertex[0]);\r\n        let nearestEdge = 0;\r\n        let i;\r\n\r\n        for (i = 1; i < this.mVertex.length; i++) {\r\n            //连接各顶点到圆心的向量，投影在各轴向量上\r\n            const distance=circ2Pos.distance(this.mVertex[i]);\r\n            if (distance < minDistance) {           //只要有一处投影长度大于0，说明圆心在矩形外\r\n                minDistance=distance;\r\n                nearestEdge=i;\r\n            }\r\n        }\r\n        const axis=[circle.mCenter.subtract(this.mVertex[nearestEdge]).normalize()];\r\n\r\n        const overlapAB=getOverLap(circle,this,axis);         //检测圆心和最近顶点组成的轴上是否有重合\r\n        if(overlapAB.overlap<=0){\r\n            return false;\r\n        }\r\n\r\n        //在B上寻找分离轴\r\n        const overlapBA=getOverLap(circle,this,this.mFaceNormal);          //检测圆心和最近顶点组成的轴上是否有重合\r\n        if(overlapBA.overlap<=0){\r\n            return false;\r\n        }\r\n\r\n        let minOverlap;\r\n        if(overlapAB.overlap<overlapBA.overlap){\r\n            minOverlap=overlapAB;\r\n        }else{\r\n            minOverlap=overlapBA;\r\n        }\r\n\r\n        //如果碰撞轴指向了圆则反转轴的方向\r\n        if (minOverlap.axis.dot( circle.mCenter.subtract( this.mCenter)) > 0) {\r\n            minOverlap.axis=minOverlap.axis.scale(-1);\r\n        }\r\n\r\n        collisionInfo.setInfo(minOverlap.overlap, minOverlap.axis, circle.mCenter.add(minOverlap.axis.scale(circle.mRadius-minOverlap.overlap)));\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\nvar contains = (vertices, point) => {\r\n    for (let i = 0; i < vertices.length; i++) {\r\n        const vertice = vertices[i];\r\n        const nextVertice = vertices[(i + 1) % vertices.length];\r\n        if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst projectToAxis = (vertices, axis) => {\r\n    const projection={};\r\n    let min = vertices[0].dot(axis);\r\n    let max = min;\r\n\r\n    for (let i = 1; i < vertices.length; i += 1) {\r\n        const dot = vertices[i].dot(axis);\r\n\r\n        if (dot > max) {\r\n            max = dot;\r\n        } else if (dot < min){\r\n            min = dot;\r\n        }\r\n    }\r\n\r\n    projection.min = min;\r\n    projection.max = max;\r\n    return projection;\r\n};\r\n\r\nvar getOverLap = (bodyA, bodyB, axes) => {\r\n    const result = { overlap: Number.MAX_VALUE };\r\n    let projectionA;\r\n    let projectionB;\r\n    let overlap;\r\n\r\n    for (const axis of axes) {\r\n        if(bodyA.mType=='Circle'){\r\n            bodyA.mVertex=[bodyA.mCenter.subtract(axis.scale(bodyA.mRadius)),bodyA.mCenter.add(axis.scale(bodyA.mRadius))]\r\n        }\r\n\r\n        projectionA=projectToAxis(bodyA.mVertex, axis);\r\n        projectionB=projectToAxis(bodyB.mVertex, axis);\r\n\r\n        overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\r\n        if (overlap <= 0) {\r\n            result.overlap = overlap;\r\n            return result;\r\n        }\r\n\r\n\r\n        if (overlap < result.overlap) {\r\n            result.overlap = overlap;\r\n            result.axis = axis;\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Rectangle);\n\n//# sourceURL=webpack:///./RigidBody/Rectangle.js?");

/***/ }),

/***/ "./RigidBody/RigidShape.js":
/*!*********************************!*\
  !*** ./RigidBody/RigidShape.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../EngineCore/Core */ \"./EngineCore/Core.js\");\n\r\n\r\n\r\nclass RigidShape {\r\n    constructor(center, mass, friction, restitution) {\r\n        this.mCenter = center;\r\n        this.mInertia = 0;\r\n        this.collided=false;\r\n        this.mMass=mass;\r\n        if (mass !== undefined) {\r\n            this.mInvMass = mass;\r\n        } else {\r\n            this.mInvMass = 1;\r\n        }\r\n\r\n        if (friction !== undefined) {\r\n            this.mFriction = friction;\r\n        } else {\r\n            this.mFriction = 0.8;\r\n        }\r\n\r\n        if (restitution !== undefined) {\r\n            this.mRestitution = restitution;\r\n        } else {\r\n            this.mRestitution = 0.2;\r\n        }\r\n\r\n        this.mVelocity = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\r\n\r\n        if (this.mInvMass !== 0) {\r\n            this.mInvMass = 1 / this.mInvMass;\r\n            this.mAcceleration = _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].gravity;\r\n        } else {\r\n            this.mAcceleration = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\r\n        }\r\n        //angle\r\n        this.mAngle = 0;\r\n\r\n        this.mAngularVelocity = 0;\r\n\r\n        this.mAngularAcceleration = 0;\r\n\r\n        this.mBoundRadius = 0;\r\n        _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addObject(this);\r\n    }\r\n\r\n    update() {\r\n        if (_EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mMovement) {\r\n            const dt = _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mUpdateIntervalInSeconds;\r\n            //v += a*t\r\n            this.mVelocity = this.mVelocity.add(this.mAcceleration.scale(dt));\r\n            //s += v*t\r\n            this.move(this.mVelocity.scale(dt));\r\n\r\n            this.mAngularVelocity += this.mAngularAcceleration * dt;\r\n            this.rotate(this.mAngularVelocity * dt);\r\n        }\r\n        /*const width = Engine.mWidth;\r\n        const height = Engine.mHeight;\r\n        if (this.mCenter.x+this.mBoundRadius < 0 || this.mCenter.x-this.mBoundRadius > width || this.mCenter.y+this.mBoundRadius < 0 || this.mCenter.y-this.mBoundRadius > height) {\r\n            const index = Engine.mAllObjects.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                Engine.mAllObjects.splice(index, 1);\r\n            }\r\n        }*/\r\n    }\r\n\r\n    boundTest(otherShape) {\r\n        const vFrom1to2 = otherShape.mCenter.subtract(this.mCenter);\r\n        const rSum = this.mBoundRadius + otherShape.mBoundRadius;\r\n        const dist = vFrom1to2.length();\r\n        if (dist > rSum) {\r\n            //not overlapping\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (RigidShape);\n\n//# sourceURL=webpack:///./RigidBody/RigidShape.js?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MyGame_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MyGame.js */ \"./MyGame.js\");\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EngineCore/Core */ \"./EngineCore/Core.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Lib/Vec2 */ \"./Lib/Vec2.js\");\n\r\n\r\n\r\n\r\n_EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].init({\r\n    gravity:new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0),\r\n    collisionResolve:false\r\n});\r\nObject(_MyGame_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n\n\n//# sourceURL=webpack:///./main.js?");

/***/ })

/******/ });