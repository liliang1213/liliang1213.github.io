/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Drawing.js":
/*!********************!*\
  !*** ./Drawing.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Drawing{\n    constructor(){\n        this.mWidth = 800;\n        this.mHeight = 450;\n\n        this.mCanvas = document.getElementById('canvas');\n        this.context = this.mCanvas.getContext('2d');\n    }\n\n    draw(mAllObjects){\n        this.context.clearRect(0, 0, this.mWidth, this.mHeight);\n        let i=mAllObjects.length;\n        while(i--){\n            if(mAllObjects[i].collided){\n                this.context.strokeStyle = 'red';\n            }else{\n                this.context.strokeStyle = 'blue';\n            }\n            if(mAllObjects[i].mType=='Circle'){\n                this.drawCircle(mAllObjects[i]);\n            }else if(mAllObjects[i].mType=='Rectangle'){\n                this.drawRect(mAllObjects[i]);\n            }else if(mAllObjects[i].mType=='Polygon'){\n                this.drawPolygon(mAllObjects[i]);\n            }\n        }\n    }\n\n    drawCircle(obj){\n        this.context.fillStyle=obj.collided?'red':'yellow';\n        this.context.beginPath();\n        this.context.arc(obj.mCenter.x, obj.mCenter.y, obj.mRadius, 0, Math.PI * 2, true);\n        this.context.moveTo(obj.mStartpoint.x, obj.mStartpoint.y);\n        this.context.lineTo(obj.mCenter.x, obj.mCenter.y);\n        this.context.fill();\n        this.context.closePath();\n        this.context.stroke();\n    }\n\n    drawRect(obj){\n        this.context.save();\n        this.context.fillStyle=obj.collided?\"red\":\"green\";\n        this.context.translate(obj.mVertex[0].x, obj.mVertex[0].y);\n        this.context.rotate(obj.mAngle);\n        this.context.fillRect(0, 0, obj.mWidth, obj.mHeight);\n        this.context.restore();\n    }\n\n    drawPolygon(obj){\n        this.context.save();\n        this.context.fillStyle=obj.collided?'red':'blue';\n        this.context.beginPath();\n        const vertices=obj.mVertex;\n        for (let i = 0; i < vertices.length; i++) {\n            const j = (i + 1) % vertices.length;\n            if(i==0) {\n                this.context.moveTo(obj.mVertex[i].x, obj.mVertex[i].y);\n            }\n            this.context.lineTo(obj.mVertex[j].x, obj.mVertex[j].y);\n        }\n        this.context.translate(obj.mVertex[0].x, obj.mVertex[0].y);\n        this.context.rotate(obj.mAngle);\n        this.context.closePath();\n        this.context.stroke();\n        this.context.fill();\n        this.context.restore();\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Drawing);\n\n//# sourceURL=webpack:///./Drawing.js?");

/***/ }),

/***/ "./EngineCore/Core.js":
/*!****************************!*\
  !*** ./EngineCore/Core.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _Lib_CollisionInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lib/CollisionInfo */ \"./Lib/CollisionInfo.js\");\n/* harmony import */ var _Drawing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Drawing */ \"./Drawing.js\");\n\n\n\n\nclass Engine {\n    constructor(opts) {\n        this.drawing=opts.drawing;\n        this.gravity = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 10);\n        this.collisionResolve=true;\n\n        this.mPositionalCorrectionFlag = true;\n        this.mRelaxationCount = 15;                  // number of relaxation iteration\n        this.mPosCorrectionRate = 0.8;               // percentage of separation to project objects\n\n        this.mCurrentTime=0;\n        this.mElapsedTime=0;\n        this.mPreviousTime = Date.now();\n        this.mLagTime = 0;\n        this.kFPS = 60;          // Frames per second\n        this.kFrameTime = 1 / this.kFPS;\n        this.mUpdateIntervalInSeconds = this.kFrameTime;\n        this.kMPF = 1000 * this.kFrameTime; // Milliseconds per frame.\n\n        this.mAllObjects = [];\n        this.mMovement = true;\n        this.collisionList=[];\n    }\n\n    addObject(obj) {\n        this.mAllObjects.push(obj);\n    }\n\n    getAllObject(){\n        return this.mAllObjects;\n    }\n\n    draw(){\n        this.drawing.draw(this.mAllObjects);\n    };\n\n    init(opts){\n        Object.assign(this,opts);\n        this.runGameLoop();\n    }\n\n    update(){\n        let mAllObjects = this.getAllObject();\n        let i=mAllObjects.length;\n        while(i--){\n            mAllObjects[i].update();\n        }\n    }\n\n    remove(obj){\n        const index = this.mAllObjects.indexOf(obj);\n\n        if (index > -1) {\n            this.mAllObjects.splice(index, 1);\n        }\n    }\n\n    runGameLoop(){\n        requestAnimationFrame(() => {\n            this.runGameLoop();\n        });\n\n        this.mCurrentTime = Date.now();\n        this.mElapsedTime = this.mCurrentTime - this.mPreviousTime;\n        this.mPreviousTime = this.mCurrentTime;\n        this.mLagTime += this.mElapsedTime;\n\n        while (this.mLagTime >= this.kMPF) {\n            this.mLagTime -= this.kMPF;\n            this.collision();\n            this.update();\n        }\n        this.draw();\n    }\n\n    addCollisionList(obj){\n        this.collisionList.push(obj);\n    }\n\n    removeCollisionList(obj){\n        const index = this.collisionList.indexOf(obj);\n\n        if (index > -1) {\n            this.collisionList.splice(index, 1);\n        }\n    }\n\n    collision(){\n        const collisionInfo = new _Lib_CollisionInfo__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        let collisionList=this.collisionList;\n        let mAllObjects=this.getAllObject();\n        let collisionObject=[];\n        let l=mAllObjects.length;\n        while(l--){\n            mAllObjects[l].collided=false;\n            if(mAllObjects[l].collisionGroup==1){\n                if(collisionList.indexOf(mAllObjects[l])<0){\n                    collisionObject.push(mAllObjects[l])\n                }\n            }\n        }\n\n        let i=collisionList.length;\n        try {\n            while (i--) {\n                let j=collisionObject.length;\n                while (j--) {\n                    if (collisionList[i] != collisionObject[j] && collisionList[i]) {\n                        if (collisionList[i].boundTest(collisionObject[j])) {\n                            if (collisionList[i].collisionTest(collisionObject[j], collisionInfo)) {\n                                collisionList[i].collided = true;\n                                collisionObject[j].collided = true;\n                                collisionList[i].emit('collision', collisionObject[j]);\n                                if (this.collisionResolve) {\n                                    if (collisionInfo.getNormal().dot(collisionObject[j].mCenter.subtract(collisionList[i].mCenter)) < 0) {\n                                        collisionInfo.changeDir();\n                                    }\n                                    this.resolveCollision(collisionList[i], collisionObject[j], collisionInfo);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }catch(e){\n            debugger;\n        }\n    };\n\n\n    positionalCorrection(s1, s2, collisionInfo){\n        const s1InvMass = s1.mInvMass;\n        const s2InvMass = s2.mInvMass;\n\n        const num = collisionInfo.getDepth() / (s1InvMass + s2InvMass) * this.mPosCorrectionRate;\n        const correctionAmount = collisionInfo.getNormal().scale(num);\n\n        s1.move(correctionAmount.scale(-s1InvMass));\n        s2.move(correctionAmount.scale(s2InvMass));\n    }\n\n    resolveCollision (s1, s2, collisionInfo) {\n\n        if ((s1.mInvMass === 0) && (s2.mInvMass === 0)) {\n            return;\n        }\n\n        //  correct positions\n        if (this.mPositionalCorrectionFlag) {\n            this.positionalCorrection(s1, s2, collisionInfo);\n        }\n\n        const n = collisionInfo.getNormal();\n\n        //the direction of collisionInfo is always from s1 to s2\n        //but the Mass is inversed, so start scale with s2 and end scale with s1\n        const start = collisionInfo.mStart.scale(s2.mInvMass / (s1.mInvMass + s2.mInvMass));\n        const end = collisionInfo.mEnd.scale(s1.mInvMass / (s1.mInvMass + s2.mInvMass));\n        const p = start.add(end);\n        //r is vector from center of object to collision point\n        const r1 = p.subtract(s1.mCenter);\n        const r2 = p.subtract(s2.mCenter);\n\n        //newV = V + mAngularVelocity cross R\n        const v1 = s1.mVelocity.add(new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](-1 * s1.mAngularVelocity * r1.y, s1.mAngularVelocity * r1.x));\n        const v2 = s2.mVelocity.add(new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](-1 * s2.mAngularVelocity * r2.y, s2.mAngularVelocity * r2.x));\n        const relativeVelocity = v2.subtract(v1);\n\n        // Relative velocity in normal direction\n        const rVelocityInNormal = relativeVelocity.dot(n);\n\n        //if objects moving apart ignore\n        if (rVelocityInNormal > 0) {\n            return;\n        }\n\n        // compute and apply response impulses for each object\n        const newRestituion = Math.min(s1.mRestitution, s2.mRestitution);\n        const newFriction = Math.min(s1.mFriction, s2.mFriction);\n\n        //R cross N\n        const R1crossN = r1.cross(n);\n        const R2crossN = r2.cross(n);\n\n        // Calc impulse scalar\n        // the formula of jN can be found in http://www.myphysicslab.com/collision.html\n        let jN = -(1 + newRestituion) * rVelocityInNormal;\n        jN = jN / (s1.mInvMass + s2.mInvMass +\n            R1crossN * R1crossN * s1.mInertia +\n            R2crossN * R2crossN * s2.mInertia);\n\n        //impulse is in direction of normal ( from s1 to s2)\n        let impulse = n.scale(jN);\n        // impulse = F dt = m * ?v\n        // ?v = impulse / m\n        s1.mVelocity = s1.mVelocity.subtract(impulse.scale(s1.mInvMass));\n        s2.mVelocity = s2.mVelocity.add(impulse.scale(s2.mInvMass));\n\n        s1.mAngularVelocity -= R1crossN * jN * s1.mInertia;\n        s2.mAngularVelocity += R2crossN * jN * s2.mInertia;\n\n        let tangent = relativeVelocity.subtract(n.scale(relativeVelocity.dot(n)));\n\n        //relativeVelocity.dot(tangent) should less than 0\n        tangent = tangent.normalize().scale(-1);\n\n        const R1crossT = r1.cross(tangent);\n        const R2crossT = r2.cross(tangent);\n\n        let jT = -(1 + newRestituion) * relativeVelocity.dot(tangent) * newFriction;\n        jT = jT / (s1.mInvMass + s2.mInvMass + R1crossT * R1crossT * s1.mInertia + R2crossT * R2crossT * s2.mInertia);\n\n        //friction should less than force in normal direction\n        if (jT > jN) {\n            jT = jN;\n        }\n\n        //impulse is from s1 to s2 (in opposite direction of velocity)\n        impulse = tangent.scale(jT);\n\n        s1.mVelocity = s1.mVelocity.subtract(impulse.scale(s1.mInvMass));\n        s2.mVelocity = s2.mVelocity.add(impulse.scale(s2.mInvMass));\n        s1.mAngularVelocity -= R1crossT * jT * s1.mInertia;\n        s2.mAngularVelocity += R2crossT * jT * s2.mInertia;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (new Engine({\n    drawing:new _Drawing__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n}));\n\n//# sourceURL=webpack:///./EngineCore/Core.js?");

/***/ }),

/***/ "./Lib/CollisionInfo.js":
/*!******************************!*\
  !*** ./Lib/CollisionInfo.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec2 */ \"./Lib/Vec2.js\");\n\n\nclass CollisionInfo {\n    constructor() {\n        this.mDepth = 0;\n        this.mNormal = new _Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\n        this.mStart = new _Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\n        this.mEnd = new _Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\n    }\n\n    /**\n     * Set the depth of the CollisionInfo\n     * @memberOf CollisionInfo\n     * @param {Number} s how much penetration\n     * @returns {void}\n     */\n    setDepth(s) {\n        this.mDepth = s;\n    }\n\n    /**\n     * Set the normal of the CollisionInfo\n     * @memberOf CollisionInfo\n     * @param {vec2} s vector upon which collision interpenetrates\n     * @returns {void}\n     */\n    setNormal(s) {\n        this.mNormal = s;\n    }\n\n    /**\n     * Return the depth of the CollisionInfo\n     * @memberOf CollisionInfo\n     * @returns {Number} how much penetration\n     */\n    getDepth() {\n        return this.mDepth;\n    }\n\n    /**\n     * Return the depth of the CollisionInfo\n     * @memberOf CollisionInfo\n     * @returns {vec2} vector upon which collision interpenetrates\n     */\n    getNormal() {\n        return this.mNormal;\n    }\n\n    /**\n     * Set the all value of the CollisionInfo\n     * @memberOf CollisionInfo\n     * @param {Number} d the depth of the CollisionInfo\n     * @param {Vec2} n the normal of the CollisionInfo\n     * @param {Vec2} s the startpoint of the CollisionInfo\n     * @returns {void}\n     */\n    setInfo(d, n, s) {\n        this.mDepth = d;\n        this.mNormal = n;\n        this.mStart = s;\n        this.mEnd = s.add(n.scale(d));\n    }\n\n    /**\n     * change the direction of normal\n     * @memberOf CollisionInfo\n     * @returns {void}\n     */\n    changeDir() {\n        this.mNormal = this.mNormal.scale(-1);\n        const n = this.mStart;\n        this.mStart = this.mEnd;\n        this.mEnd = n;\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (CollisionInfo);\n\n//# sourceURL=webpack:///./Lib/CollisionInfo.js?");

/***/ }),

/***/ "./Lib/Vec2.js":
/*!*********************!*\
  !*** ./Lib/Vec2.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Vec2 {\n    constructor(x, y) {\n        if(x===undefined||y===undefined){\n            console.error('Vec2 construct with error params');\n        }\n        this.x = x;\n        this.y = y;\n    }\n\n    add(vec) {\n        return new Vec2(vec.x + this.x, vec.y + this.y);\n    }\n\n    subtract(vec) {\n        return new Vec2(this.x - vec.x, this.y - vec.y);\n    }\n\n    scale(n) {\n        return new Vec2(this.x * n, this.y * n);\n    }\n\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    dot(vec) {\n        return (this.x * vec.x + this.y * vec.y);\n    }\n\n    cross(vec) {\n        return (this.x * vec.y - this.y * vec.x);\n    }\n\n    rotate(center, angle) {\n        let x1;\n        let y1;\n\n        const x = this.x - center.x;\n        const y = this.y - center.y;\n\n        x1 = x * Math.cos(angle) - y * Math.sin(angle);\n        y1 = x * Math.sin(angle) + y * Math.cos(angle);\n\n        x1 += center.x;\n        y1 += center.y;\n\n        return new Vec2(x1, y1);\n    }\n\n    normalize() {\n\n        let len = this.length();\n        if (len > 0) {\n            len = 1 / len;\n        }\n        return new Vec2(this.x * len, this.y * len);\n    }\n\n    distance(vec) {\n        const x = this.x - vec.x;\n        const y = this.y - vec.y;\n        return Math.sqrt(x * x + y * y);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vec2);\n\n//# sourceURL=webpack:///./Lib/Vec2.js?");

/***/ }),

/***/ "./Lib/utils.js":
/*!**********************!*\
  !*** ./Lib/utils.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EngineCore/Core */ \"./EngineCore/Core.js\");\n\nfunction drawLine(start,end){\n    var context=_EngineCore_Core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mContext;\n    context.strokeStyle = 'purple';\n    context.beginPath();\n    context.moveTo(start.x,start.y);\n    context.lineTo(end.x, end.y);\n\n    context.closePath();\n    context.stroke();\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    drawLine:drawLine\n});\n\n//# sourceURL=webpack:///./Lib/utils.js?");

/***/ }),

/***/ "./MyGame.js":
/*!*******************!*\
  !*** ./MyGame.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RigidBody_Rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RigidBody/Rectangle */ \"./RigidBody/Rectangle.js\");\n/* harmony import */ var _RigidBody_Polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RigidBody/Polygon */ \"./RigidBody/Polygon.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _RigidBody_Circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RigidBody/Circle */ \"./RigidBody/Circle.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EngineCore/Core */ \"./EngineCore/Core.js\");\n\n\n\n\n\n\n\n\nclass MovingPath extends events__WEBPACK_IMPORTED_MODULE_2___default.a {\n    constructor(opts) {\n        super();\n        this.params = {\n            type: 'smooth',\n          /*  points: [{\n                x: 300,\n                y: 300\n            }, {\n                x: 600,\n                y: 100\n            }]*/\n            points:[{\n                x:300,\n                y:300\n            },{\n                x:600,\n                y:100\n            },{\n                x:100,\n                y:100\n            },{\n                x:50,\n                y:600\n            }]\n        };\n        this.status = 'start';\n        this.maxSpeed = 100;\n        this.obj = opts.obj;\n        this.judge = null;\n        this.currentPointIndex = 0;\n        this.dist = this.getDist();\n    }\n\n    single(dist) {\n        var obj = this.obj;\n        switch (this.params.type) {\n            case 'smooth':\n                var desire = dist.subtract(obj.mCenter).normalize().scale(this.maxSpeed);\n                var steer = desire.subtract(obj.mVelocity);\n                obj.mAcceleration = steer;\n                this.judge = Math.atan2(dist.y - obj.mCenter.y, dist.x - obj.mCenter.x);\n                obj.rotate(Math.atan2(obj.mVelocity.y, obj.mVelocity.x) - obj.mAngle);\n                break;\n            case 'direct':\n                var desire = dist.subtract(obj.mCenter).normalize().scale(this.maxSpeed);\n                obj.mVelocity = desire;\n                this.judge = Math.atan2(dist.y - obj.mCenter.y, dist.x - obj.mCenter.x);\n                obj.rotate(Math.atan2(obj.mVelocity.y, obj.mVelocity.x) - obj.mAngle);\n                break;\n        }\n    }\n\n    getDist() {\n        return new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.params.points[this.currentPointIndex].x, this.params.points[this.currentPointIndex].y);\n    }\n\n    moving() {\n        if (this.status == 'end') {\n            return false;\n        }\n        var dist = this.dist;\n        var obj = this.obj;\n\n        if (Math.atan2(dist.y - obj.mCenter.y, dist.x - obj.mCenter.x) * this.judge < 0) {\n            this.currentPointIndex++;\n            if (this.currentPointIndex == this.params.points.length) {\n                this.status = 'end';\n                this.emit('end');\n                return false;\n            }\n            this.dist = this.getDist();\n        }\n        this.single(this.dist);\n    }\n}\n\nfunction MyGame() {\n    var cannon = new _RigidBody_Rectangle__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        pos: new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](200, 300),\n        width: 40,\n        height: 40,\n        mass: 0,\n        friction: 1,\n        restitution: 0.1,\n        collisionGroup: 0\n    });\n\n    var r4 = new _RigidBody_Rectangle__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n        {\n            pos: new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](200, 100),\n            width: 40,\n            height: 20,\n            mass: 0,\n            friction: 1,\n            restitution: 0.1\n        });\n\n    var circle = new _RigidBody_Circle__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\n        {\n            pos: new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](260.7774466923317, 53.158349874831984),\n            radius: 13.690461478357165,\n            mass: 0,\n            friction: 1,\n            restitution: 0.1\n        });\n\n    var fish = new MovingPath({\n        obj: r4\n    });\n\n    var p1=new _RigidBody_Polygon__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        pos:new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](300,300),\n        vertices:[new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](0,-100),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](50,-50),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](50,0),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](50,50),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](0,100),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](-50,50),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](-50,0),new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](-50,-50)],\n    })\n\n    var interval = null;\n    fish.on('end', function () {\n        if (interval) {\n            clearInterval(interval);\n            // Engine.remove(r4);\n            r4.setStatic();\n            console.log('finished')\n        }\n    });\n\n    interval = setInterval(function () {\n        fish.moving()\n    }, 50);\n\n    _EngineCore_Core__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawing.mCanvas.onmousedown = function (event) {\n        // console.log(event,\"event\");\n        var angle = Math.atan2(event.clientY - cannon.y, event.clientX - cannon.x)\n        cannon.rotate(angle - cannon.mAngle);\n        var bullet = new _RigidBody_Rectangle__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n            {\n                pos: new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](200, 300),\n                width: 40,\n                height: 20,\n                mass: 0,\n                friction: 1,\n                restitution: 0.1,\n                collisionGroup:2\n            });\n\n        var bulletVelocity = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](event.clientX, event.clientY).subtract(bullet.mCenter).normalize().scale(300);\n        bullet.rotate(angle);\n        bullet.mVelocity = bulletVelocity;\n        bullet.addCollisionListener(function (obj) {\n            _EngineCore_Core__WEBPACK_IMPORTED_MODULE_5__[\"default\"].removeCollisionList(obj);\n            console.log(obj, \"obj\");\n        });\n\n        bullet.on('update',(bullet)=>{\n            let width = _EngineCore_Core__WEBPACK_IMPORTED_MODULE_5__[\"default\"].mWidth;\n            let height = _EngineCore_Core__WEBPACK_IMPORTED_MODULE_5__[\"default\"].mHeight;\n            if (bullet.x< 0 || bullet.x > width) {\n                bullet.mVelocity.x=-bullet.mVelocity.x;\n                bullet.rotate(Math.atan2(bullet.mVelocity.y,bullet.mVelocity.x)-bullet.mAngle)\n            }\n\n            if(bullet.y< 0 || bullet.y> height){\n                bullet.mVelocity.y=-bullet.mVelocity.y;\n                bullet.rotate(Math.atan2(bullet.mVelocity.y,bullet.mVelocity.x)-bullet.mAngle)\n            }\n        })\n    }\n}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyGame);\n\n\n\n\n//# sourceURL=webpack:///./MyGame.js?");

/***/ }),

/***/ "./RigidBody/Circle.js":
/*!*****************************!*\
  !*** ./RigidBody/Circle.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RigidShape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RigidShape */ \"./RigidBody/RigidShape.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n\n\n\nclass Circle extends _RigidShape__WEBPACK_IMPORTED_MODULE_0__[\"default\"]{\n    constructor(opts) {\n        super(opts);\n        this.mType = \"Circle\";\n        this.mRadius = opts.radius;\n        this.mBoundRadius = opts.radius;\n        let pos=opts.pos;\n        this.mStartpoint = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](pos.x, pos.y - this.mRadius);\n        this.updateInertia();\n    }\n\n    move(s) {\n        this.mStartpoint = this.mStartpoint.add(s);\n        this.mCenter = this.mCenter.add(s);\n        this.x=this.mCenter.x;\n        this.y=this.mCenter.y;\n        return this;\n    }\n\n    rotate(angle) {\n        this.mAngle += angle;\n        this.mStartpoint = this.mStartpoint.rotate(this.mCenter, angle);\n        return this;\n    }\n\n    updateInertia() {\n        if (this.mInvMass === 0) {\n            this.mInertia = 0;\n        } else {\n            // this.mInvMass is inverted!!\n            // Inertia=mass * radius^2\n            // 12 is a constant value that can be changed\n            this.mInertia = (1 / this.mInvMass) * (this.mRadius * this.mRadius) / 12;\n        }\n    }\n\n    collisionTest(otherShape, collisionInfo) {\n        let status = false;\n        if (otherShape.mType === \"Circle\") {\n            status = this.collidedCircCirc(this, otherShape, collisionInfo);\n        } else {\n            status = otherShape.collidedRectCirc(this, collisionInfo);\n        }\n        return status;\n    }\n\n    collidedCircCirc(c1, c2, collisionInfo) {\n        const vFrom1to2 = c2.mCenter.subtract(c1.mCenter);\n        const rSum = c1.mRadius + c2.mRadius;\n        const dist = vFrom1to2.length();\n        //圆心距离大于半径之和\n        if (dist > Math.sqrt(rSum * rSum)) {\n            return false;\n        }\n        if (dist !== 0) {\n            //有重叠但位置不同\n            const normalFrom2to1 = vFrom1to2.scale(-1).normalize();\n            const radiusC2 = normalFrom2to1.scale(c2.mRadius);\n            collisionInfo.setInfo(rSum - dist, vFrom1to2.normalize(), c2.mCenter.add(radiusC2));\n        } else {\n            //位置相同\n            if (c1.mRadius > c2.mRadius) {\n                collisionInfo.setInfo(rSum, new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, -1), c1.mCenter.add(new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, c1.mRadius)));\n            } else {\n                collisionInfo.setInfo(rSum, new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, -1), c2.mCenter.add(new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, c2.mRadius)));\n            }\n        }\n        return true;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Circle);\n\n//# sourceURL=webpack:///./RigidBody/Circle.js?");

/***/ }),

/***/ "./RigidBody/Polygon.js":
/*!******************************!*\
  !*** ./RigidBody/Polygon.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RigidShape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RigidShape */ \"./RigidBody/RigidShape.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EngineCore/Core */ \"./EngineCore/Core.js\");\n\n\n\n\nconst Vertices={};\n\nVertices.centre = vertices => {\n    const area = Vertices.area(vertices, true);\n    let centre = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"]( 0,  0 );\n    let cross;\n    let temp;\n    let j;\n\n    for (let i = 0; i < vertices.length; i++) {\n        j = (i + 1) % vertices.length;\n        cross = vertices[i].cross(vertices[j]);\n        temp = vertices[i].add(vertices[j]).scale(cross);\n        centre = centre.add(temp);\n    }\n\n    return centre.scale(1/(6 * area));\n};\n\nVertices.area = (vertices, signed) => {\n    let area = 0;\n    let j = vertices.length - 1;\n\n    for (let i = 0; i < vertices.length; i++) {\n        area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n        j = i;\n    }\n\n    if (signed)\n        return area / 2;\n    return Math.abs(area) / 2;\n};\n\nVertices.inertia = (vertices, mass) => {\n    let numerator = 0;\n    let denominator = 0;\n    const v = vertices;\n    let cross;\n    let j;\n\n    for (let n = 0; n < v.length; n++) {\n        j = (n + 1) % v.length;\n        cross = Math.abs(v[j].cross(v[n]));\n        numerator += cross * (v[j].dot( v[j]) + v[j].dot( v[n]) + v[n].dot( v[n]));\n        denominator += cross;\n    }\n\n    return (mass / 6) * (numerator / denominator);\n};\n\nclass Polygon extends _RigidShape__WEBPACK_IMPORTED_MODULE_0__[\"default\"]{\n    constructor(opts) {\n        super(opts);\n        this.mType = \"Polygon\";\n        this.mCenter=Vertices.centre(opts.vertices);\n        this.mVertex=[];\n        for(let i=0;i<opts.vertices.length;i++){\n            this.mVertex[i] = opts.pos.add(opts.vertices[i]);\n        }\n        this.mBoundRadius = this.getRadius(this.mVertex);\n        this.mFaceNormal=this.getAxes();\n        this.updateInertia();\n    }\n\n    getRadius(vertices) {\n        let radius = 0;\n\n        for (let i = 0; i < vertices.length; i++) {\n            if(vertices[i].distance(this.mCenter)>radius){\n                radius=vertices[i].distance(this.mCenter)\n            }\n        }\n\n        return radius;\n    }\n\n    getAxes() {\n        const axes = [];\n        const vertices=this.mVertex;\n        for (let i = 0; i < vertices.length; i++) {\n            const j = (i + 1) % vertices.length;\n\n            const normal = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n                vertices[j].y - vertices[i].y,\n                vertices[i].x - vertices[j].x\n            ).normalize();\n\n            axes[i] = normal;\n        }\n        return axes;\n    }\n\n    rotate(angle) {\n        this.mAngle += angle;\n        let i;\n        for (i = 0; i < this.mVertex.length; i++) {\n            this.mVertex[i] = this.mVertex[i].rotate(this.mCenter, angle);\n        }\n        this.mFaceNormal=this.getAxes();\n        return this;\n    }\n\n    move(v) {\n        let i;\n        for (i = 0; i < this.mVertex.length; i++) {\n            this.mVertex[i] = this.mVertex[i].add(v);\n        }\n        this.mCenter = this.mCenter.add(v);\n        this.x=this.mCenter.x;\n        this.y=this.mCenter.y;\n        return this;\n    }\n\n    updateInertia() {\n        // Expect this.mInvMass to be already inverted!\n        if (this.mInvMass === 0) {\n            this.mInertia = 0;\n        } else {\n            this.mInertia=Vertices.inertia(this.mVertex,this.mMass);\n            this.mInertia = 1 / this.mInertia;\n        }\n    }\n\n    collisionTest(otherShape, collisionInfo) {\n        let status = false;\n        if (otherShape.mType === \"Circle\") {\n            status = this.collidedRectCirc(otherShape, collisionInfo);\n        } else {\n            status = this.collidedRectRect(this, otherShape, collisionInfo);\n        }\n        return status;\n    }\n\n    collidedRectRect(A, B, collisionInfo) {\n        //在A上寻找分离轴\n        const overlapAB = getOverLap(A,B,A.mFaceNormal);\n        if(overlapAB.overlap<=0){\n            return false;\n        }\n\n        //在B上寻找分离轴\n        const overlapBA = getOverLap(B,A,B.mFaceNormal);\n        if(overlapBA.overlap<=0){\n            return false;\n        }\n\n        let minOverlap;\n        if(overlapAB.overlap<overlapBA.overlap){\n            minOverlap=overlapAB;\n        }else{\n            minOverlap=overlapBA;\n        }\n\n        //纠正轴向量的方向\n        if (minOverlap.axis.dot( B.mCenter.subtract( A.mCenter)) < 0) {\n            minOverlap.axis=minOverlap.axis.scale(-1);\n        }\n\n        //寻找支撑点\n        const supportB=A.findSupportPoint(minOverlap.axis,B);   //在B上找支撑点,A是小盒子\n        const supportA=B.findSupportPoint(minOverlap.axis.scale(-1),A);   //在A上找支撑点\n        let support;\n        const gContext=_EngineCore_Core__WEBPACK_IMPORTED_MODULE_2__[\"default\"].mContext;\n\n        support=supportB;\n        if(contains(B.mVertex,supportA)){\n            support=supportA;\n        }\n\n        /* gContext.strokeStyle = 'purple';\n         gContext.beginPath();\n         gContext.moveTo(0,0);\n         gContext.lineTo(support.x, support.y);\n\n         gContext.closePath();\n         gContext.stroke();*/\n\n        collisionInfo.setInfo(minOverlap.overlap, minOverlap.axis, support);\n        return true;\n    }\n\n    findSupportPoint(axis, rect) {\n        let support=null;\n        let vertex;\n        let distance;\n        let nearestDistance=Number.MAX_VALUE;\n\n        const tempVertex= new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0,0);\n\n        const vertices=rect.mVertex;\n        for (let i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            tempVertex.x = vertex.x - this.mCenter.x;\n            tempVertex.y = vertex.y - this.mCenter.y;\n            distance = tempVertex.dot(axis);\n\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                support = vertices[i];\n            }\n        }\n        return support;\n    }\n\n    collidedRectCirc(circle, collisionInfo) {\n        const circ2Pos=circle.mCenter;\n        let minDistance =circ2Pos.distance(this.mVertex[0]);\n        let nearestEdge = 0;\n        let i;\n\n        for (i = 1; i < this.mVertex.length; i++) {\n            //连接各顶点到圆心的向量，投影在各轴向量上\n            const distance=circ2Pos.distance(this.mVertex[i]);\n            if (distance < minDistance) {           //只要有一处投影长度大于0，说明圆心在矩形外\n                minDistance=distance;\n                nearestEdge=i;\n            }\n        }\n        const axis=[circle.mCenter.subtract(this.mVertex[nearestEdge]).normalize()];\n\n        const overlapAB=getOverLap(circle,this,axis);         //检测圆心和最近顶点组成的轴上是否有重合\n        if(overlapAB.overlap<=0){\n            return false;\n        }\n\n        //在B上寻找分离轴\n        const overlapBA=getOverLap(circle,this,this.mFaceNormal);          //检测圆心和最近顶点组成的轴上是否有重合\n        if(overlapBA.overlap<=0){\n            return false;\n        }\n\n        let minOverlap;\n        if(overlapAB.overlap<overlapBA.overlap){\n            minOverlap=overlapAB;\n        }else{\n            minOverlap=overlapBA;\n        }\n\n        //如果碰撞轴指向了圆则反转轴的方向\n        if (minOverlap.axis.dot( circle.mCenter.subtract( this.mCenter)) > 0) {\n            minOverlap.axis=minOverlap.axis.scale(-1);\n        }\n\n        collisionInfo.setInfo(minOverlap.overlap, minOverlap.axis, circle.mCenter.add(minOverlap.axis.scale(circle.mRadius-minOverlap.overlap)));\n        return true;\n    }\n}\n\nvar contains = (vertices, point) => {\n    for (let i = 0; i < vertices.length; i++) {\n        const vertice = vertices[i];\n        const nextVertice = vertices[(i + 1) % vertices.length];\n        if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nconst projectToAxis = (vertices, axis) => {\n    const projection={};\n    let min = vertices[0].dot(axis);\n    let max = min;\n\n    for (let i = 1; i < vertices.length; i += 1) {\n        const dot = vertices[i].dot(axis);\n\n        if (dot > max) {\n            max = dot;\n        } else if (dot < min){\n            min = dot;\n        }\n    }\n\n    projection.min = min;\n    projection.max = max;\n    return projection;\n};\n\nvar getOverLap = (bodyA, bodyB, axes) => {\n    const result = { overlap: Number.MAX_VALUE };\n    let projectionA;\n    let projectionB;\n    let overlap;\n\n    for (const axis of axes) {\n        if(bodyA.mType=='Circle'){\n            bodyA.mVertex=[bodyA.mCenter.subtract(axis.scale(bodyA.mRadius)),bodyA.mCenter.add(axis.scale(bodyA.mRadius))]\n        }\n\n        projectionA=projectToAxis(bodyA.mVertex, axis);\n        projectionB=projectToAxis(bodyB.mVertex, axis);\n\n        overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\n        if (overlap <= 0) {\n            result.overlap = overlap;\n            return result;\n        }\n\n\n        if (overlap < result.overlap) {\n            result.overlap = overlap;\n            result.axis = axis;\n        }\n    }\n\n    return result;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Polygon);\n\n//# sourceURL=webpack:///./RigidBody/Polygon.js?");

/***/ }),

/***/ "./RigidBody/Rectangle.js":
/*!********************************!*\
  !*** ./RigidBody/Rectangle.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RigidShape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RigidShape */ \"./RigidBody/RigidShape.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _Lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Lib/utils */ \"./Lib/utils.js\");\n\n\n\n\nclass Rectangle extends _RigidShape__WEBPACK_IMPORTED_MODULE_0__[\"default\"]{\n    constructor(opts) {\n        super(opts);\n        this.mType = \"Rectangle\";\n        this.mWidth = opts.width;\n        this.mHeight = opts.height;\n        let center=opts.pos,width=opts.width,height=opts.height;\n        this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\n        this.mVertex = [];\n        this.mFaceNormal = [];\n\n        //0--TopLeft;1--TopRight;2--BottomRight;3--BottomLeft\n        this.mVertex[0] = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](center.x - width / 2, center.y - height / 2);\n        this.mVertex[1] = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](center.x + width / 2, center.y - height / 2);\n        this.mVertex[2] = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](center.x + width / 2, center.y + height / 2);\n        this.mVertex[3] = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](center.x - width / 2, center.y + height / 2);\n        //0--Top;1--Right;2--Bottom;3--Left\n        this.mFaceNormal=this.getAxes();\n        this.updateInertia();\n    }\n\n    getAxes() {\n        const axes = [];\n        const vertices=this.mVertex;\n        for (let i = 0; i < vertices.length; i++) {\n            const j = (i + 1) % vertices.length;\n\n            const normal = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n                vertices[j].y - vertices[i].y,\n                vertices[i].x - vertices[j].x\n            ).normalize();\n\n            axes[i] = normal;\n        }\n\n        return axes;\n    }\n\n    rotate(angle) {\n        this.mAngle += angle;\n        let i;\n        for (i = 0; i < this.mVertex.length; i++) {\n            this.mVertex[i] = this.mVertex[i].rotate(this.mCenter, angle);\n        }\n        this.mFaceNormal=this.getAxes();\n        return this;\n    }\n\n    move(v) {\n        let i;\n        for (i = 0; i < this.mVertex.length; i++) {\n            this.mVertex[i] = this.mVertex[i].add(v);\n        }\n        this.mCenter = this.mCenter.add(v);\n        this.x=this.mCenter.x;\n        this.y=this.mCenter.y;\n        return this;\n    }\n\n    updateInertia() {\n        // Expect this.mInvMass to be already inverted!\n        if (this.mInvMass === 0) {\n            this.mInertia = 0;\n        } else {\n            //inertia=mass*width^2+height^2\n            this.mInertia = (1 / this.mInvMass) * (this.mWidth * this.mWidth + this.mHeight * this.mHeight) / 12;\n            this.mInertia = 1 / this.mInertia;\n        }\n    }\n\n    collisionTest(otherShape, collisionInfo) {\n        let status = false;\n        if (otherShape.mType === \"Circle\") {\n            status = this.collidedRectCirc(otherShape, collisionInfo);\n        } else {\n            status = this.collidedRectRect(this, otherShape, collisionInfo);\n        }\n        return status;\n    }\n\n    collidedRectRect(A, B, collisionInfo) {\n\n        //在A上寻找分离轴\n        const overlapAB = getOverLap(A,B,A.mFaceNormal);\n        if(overlapAB.overlap<=0){\n            return false;\n        }\n\n        //在B上寻找分离轴\n        const overlapBA = getOverLap(B,A,B.mFaceNormal);\n        if(overlapBA.overlap<=0){\n            return false;\n        }\n\n        let minOverlap;\n        if(overlapAB.overlap<overlapBA.overlap){\n            minOverlap=overlapAB;\n        }else{\n            minOverlap=overlapBA;\n        }\n        //纠正轴向量的方向\n        try {\n            if (minOverlap.axis.dot(B.mCenter.subtract(A.mCenter)) < 0) {\n                minOverlap.axis = minOverlap.axis.scale(-1);\n            }\n        }catch(e){\n            debugger;\n        }\n        //寻找支撑点\n        const supportB=A.findSupportPoint(minOverlap.axis,B);   //在B上找支撑点,A是小盒子\n        const supportA=B.findSupportPoint(minOverlap.axis.scale(-1),A);   //在A上找支撑点\n        let support;\n\n        support=supportB;\n        if(contains(B.mVertex,supportA)){\n            support=supportA;\n\n        }\n\n        /*  gContext.strokeStyle = 'green';\n         gContext.beginPath();\n         gContext.moveTo(0,0);\n         gContext.lineTo(B.mCenter.x, B.mCenter.y);\n\n         gContext.closePath();\n         gContext.stroke();*/\n\n        collisionInfo.setInfo(minOverlap.overlap, minOverlap.axis, support);\n        return true;\n    }\n\n    findSupportPoint(axis, rect) {\n        let support=null;\n        let vertex;\n        let distance;\n        let nearestDistance=Number.MAX_VALUE;\n\n        const tempVertex= new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0,0);\n\n        const vertices=rect.mVertex;\n        for (let i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            tempVertex.x = vertex.x - this.mCenter.x;\n            tempVertex.y = vertex.y - this.mCenter.y;\n            distance = tempVertex.dot(axis);\n\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                support = vertices[i];\n            }\n        }\n        return support;\n    }\n\n    collidedRectCirc(circle, collisionInfo) {\n        const circ2Pos=circle.mCenter;\n        let minDistance =circ2Pos.distance(this.mVertex[0]);\n        let nearestEdge = 0;\n        let i;\n\n        for (i = 1; i < this.mVertex.length; i++) {\n            //连接各顶点到圆心的向量，投影在各轴向量上\n            const distance=circ2Pos.distance(this.mVertex[i]);\n            if (distance < minDistance) {           //只要有一处投影长度大于0，说明圆心在矩形外\n                minDistance=distance;\n                nearestEdge=i;\n            }\n        }\n        const axis=[circle.mCenter.subtract(this.mVertex[nearestEdge]).normalize()];\n\n        const overlapAB=getOverLap(circle,this,axis);         //检测圆心和最近顶点组成的轴上是否有重合\n        if(overlapAB.overlap<=0){\n            return false;\n        }\n\n        //在B上寻找分离轴\n        const overlapBA=getOverLap(circle,this,this.mFaceNormal);          //检测圆心和最近顶点组成的轴上是否有重合\n        if(overlapBA.overlap<=0){\n            return false;\n        }\n\n        let minOverlap;\n        if(overlapAB.overlap<overlapBA.overlap){\n            minOverlap=overlapAB;\n        }else{\n            minOverlap=overlapBA;\n        }\n\n        //如果碰撞轴指向了圆则反转轴的方向\n        if (minOverlap.axis.dot( circle.mCenter.subtract( this.mCenter)) > 0) {\n            minOverlap.axis=minOverlap.axis.scale(-1);\n        }\n\n        collisionInfo.setInfo(minOverlap.overlap, minOverlap.axis, circle.mCenter.add(minOverlap.axis.scale(circle.mRadius-minOverlap.overlap)));\n        return true;\n    }\n}\n\n\nvar contains = (vertices, point) => {\n    for (let i = 0; i < vertices.length; i++) {\n        const vertice = vertices[i];\n        const nextVertice = vertices[(i + 1) % vertices.length];\n        if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\nconst projectToAxis = (vertices, axis) => {\n    const projection={};\n    let min = vertices[0].dot(axis);\n    let max = min;\n\n    for (let i = 1; i < vertices.length; i += 1) {\n        const dot = vertices[i].dot(axis);\n\n        if (dot > max) {\n            max = dot;\n        } else if (dot < min){\n            min = dot;\n        }\n    }\n\n    projection.min = min;\n    projection.max = max;\n    return projection;\n};\n\nvar getOverLap = (bodyA, bodyB, axes) => {\n    const result = { overlap: Number.MAX_VALUE };\n    let projectionA;\n    let projectionB;\n    let overlap;\n\n    for (const axis of axes) {\n        if(bodyA.mType=='Circle'){\n            bodyA.mVertex=[bodyA.mCenter.subtract(axis.scale(bodyA.mRadius)),bodyA.mCenter.add(axis.scale(bodyA.mRadius))]\n        }\n\n        projectionA=projectToAxis(bodyA.mVertex, axis);\n        projectionB=projectToAxis(bodyB.mVertex, axis);\n\n        overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\n        if (overlap <= 0) {\n            result.overlap = overlap;\n            return result;\n        }\n\n\n        if (overlap < result.overlap) {\n            result.overlap = overlap;\n            result.axis = axis;\n        }\n    }\n\n    return result;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Rectangle);\n\n//# sourceURL=webpack:///./RigidBody/Rectangle.js?");

/***/ }),

/***/ "./RigidBody/RigidShape.js":
/*!*********************************!*\
  !*** ./RigidBody/RigidShape.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lib/Vec2 */ \"./Lib/Vec2.js\");\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../EngineCore/Core */ \"./EngineCore/Core.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nclass RigidShape extends events__WEBPACK_IMPORTED_MODULE_2___default.a{\n    constructor(opts) {\n        let mass=opts.mass;\n        let friction=opts.friction;\n        let restitution=opts.restitution;\n        super();\n        this.mCenter = opts.pos;\n        this.x=this.mCenter.x;\n        this.y=this.mCenter.y;\n        this.mInertia = 0;\n        this.collisionGroup=opts.collisionGroup||1;\n        this.collided=false;\n        this.mMass=mass;\n        if (mass !== undefined) {\n            this.mInvMass = mass;\n        } else {\n            this.mInvMass = 1;\n        }\n\n        if (friction !== undefined) {\n            this.mFriction = friction;\n        } else {\n            this.mFriction = 0.8;\n        }\n\n        if (restitution !== undefined) {\n            this.mRestitution = restitution;\n        } else {\n            this.mRestitution = 0.2;\n        }\n\n        this.mVelocity = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\n\n        if (this.mInvMass !== 0) {\n            this.mInvMass = 1 / this.mInvMass;\n            this.mAcceleration = _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].gravity;\n        } else {\n            this.mAcceleration = new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0);\n        }\n        //angle\n        this.mAngle = 0;\n\n        this.mAngularVelocity = 0;\n\n        this.mAngularAcceleration = 0;\n\n        this.mBoundRadius = 0;\n        _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addObject(this);\n    }\n\n    setStatic(){\n        this.mAcceleration.x=0;\n        this.mAcceleration.y=0;\n        this.mVelocity.x=0;\n        this.mVelocity.y=0;\n    }\n\n    update() {\n        if (_EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mMovement) {\n            const dt = _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mUpdateIntervalInSeconds;\n            //v += a*t\n            this.mVelocity = this.mVelocity.add(this.mAcceleration.scale(dt));\n            //s += v*t\n            this.move(this.mVelocity.scale(dt));\n\n            this.mAngularVelocity += this.mAngularAcceleration * dt;\n            this.rotate(this.mAngularVelocity * dt);\n        }\n        this.emit('update',this);\n        /*const width = Engine.mWidth;\n        const height = Engine.mHeight;\n        if (this.mCenter.x+this.mBoundRadius < 0 || this.mCenter.x-this.mBoundRadius > width || this.mCenter.y+this.mBoundRadius < 0 || this.mCenter.y-this.mBoundRadius > height) {\n            const index = Engine.mAllObjects.indexOf(this);\n\n            if (index > -1) {\n                Engine.mAllObjects.splice(index, 1);\n            }\n        }*/\n    }\n\n    boundTest(otherShape) {\n        const vFrom1to2 = otherShape.mCenter.subtract(this.mCenter);\n        const rSum = this.mBoundRadius + otherShape.mBoundRadius;\n        const dist = vFrom1to2.length();\n        if (dist > rSum) {\n            return false;\n        }\n        return true;\n    }\n\n    addCollisionListener(callback){\n        if(typeof callback!='function'){\n            console.error('No collision callback function');\n        }\n        _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addCollisionList(this);\n        let collisionCb=function(){\n            let args=Array.prototype.slice.call(arguments)\n            callback.apply(this,args)\n            this.removeListener('collision',collisionCb);\n        };\n        this.on('collision',collisionCb);\n\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (RigidShape);\n\n//# sourceURL=webpack:///./RigidBody/RigidShape.js?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MyGame_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MyGame.js */ \"./MyGame.js\");\n/* harmony import */ var _EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EngineCore/Core */ \"./EngineCore/Core.js\");\n/* harmony import */ var _Lib_Vec2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Lib/Vec2 */ \"./Lib/Vec2.js\");\n\n\n\n\n_EngineCore_Core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].init({\n    gravity:new _Lib_Vec2__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0),\n    collisionResolve:false\n});\nObject(_MyGame_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n\n//# sourceURL=webpack:///./main.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ })

/******/ });